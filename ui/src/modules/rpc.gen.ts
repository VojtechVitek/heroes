/* eslint-disable */
// HeroesServer vTODO e808e3ca2d149f99cfe85da9adce7ca9ee7b769e
// --
// Code generated by webrpc-gen@v0.7.0 with typescript generator. DO NOT EDIT.
//
// webrpc-gen -schema=./rpc/webrpc.json -target=typescript -client -out=./ui/src/modules/rpc.gen.ts

// WebRPC description and code-gen version
export const WebRPCVersion = "v1"

// Schema version of your RIDL schema
export const WebRPCSchemaVersion = "vTODO"

// Schema hash generated from your RIDL schema
export const WebRPCSchemaHash = "e808e3ca2d149f99cfe85da9adce7ca9ee7b769e"

//
// Types
//
export interface H3mPosition {
  X: number
  Y: number
  Z: number
}

export interface H3mCustomHeroes {
  Type: number
  Face: number
  Name: string
  AllowedPlayers: number
}

export interface H3mMapInfo {
  HasHero: boolean
  MapSize: number
  HasTwoLevels: boolean
  Name: string
  Desc: string
  Difficulty: number
  WinCondition: number
  WinConditionAllowNormalWin: boolean
  WinConditionAppliesToComputer: boolean
  WinConditionType: number
  WinConditionAmount: number
  WinConditionUpgradeHallLevel: number
  WinConditionUpgradeCastleLevel: number
  WinConditionPos: H3mPosition
  LoseCondition: number
  LoseConditionPos: H3mPosition
  LoseConditionDays: number
  TeamsCount: number
  Teams: Array<number>
  AvailableHeroes: Array<string>
  CustomHeroesCount: number
  CustomHeroes: Array<H3mCustomHeroes>
}

export interface H3mPlayer {
  MasteryCap: number
  CanBeHuman: boolean
  CanBeComputer: boolean
  Behavior: number
  AllowedAlignments: number
  TownTypes: number
  HasRandomTown: boolean
  HasMainTown: boolean
  StartingTownCreateHero: boolean
  StartingTown: number
  StartingTownPos: H3mPosition
  StartingHeroIsRandom: boolean
  StartingHeroType: number
  StartingHeroFace: number
  StartingHeroName: string
}

export interface H3mTile {
  TerrainType: number
  TerrainSprite: number
  RiverType: number
  RiverSprite: number
  RoadType: number
  RoadSprite: number
  Mirroring: number
}

export interface H3mH3M {
  Format: number
  HasHero: boolean
  MapSize: number
  HasTwoLevels: boolean
  Name: string
  Desc: string
  Difficulty: number
  WinCondition: number
  WinConditionAllowNormalWin: boolean
  WinConditionAppliesToComputer: boolean
  WinConditionType: number
  WinConditionAmount: number
  WinConditionUpgradeHallLevel: number
  WinConditionUpgradeCastleLevel: number
  WinConditionPos: H3mPosition
  LoseCondition: number
  LoseConditionPos: H3mPosition
  LoseConditionDays: number
  TeamsCount: number
  Teams: Array<number>
  AvailableHeroes: Array<string>
  CustomHeroesCount: number
  CustomHeroes: Array<H3mCustomHeroes>
  Players: Array<H3mPlayer>
  Tiles: Array<H3mTile>
}

export interface Map {
  Format: number
  HasHero: boolean
  MapSize: number
  HasTwoLevels: boolean
  Name: string
  Desc: string
  Difficulty: number
  WinCondition: number
  WinConditionAllowNormalWin: boolean
  WinConditionAppliesToComputer: boolean
  WinConditionType: number
  WinConditionAmount: number
  WinConditionUpgradeHallLevel: number
  WinConditionUpgradeCastleLevel: number
  WinConditionPos: H3mPosition
  LoseCondition: number
  LoseConditionPos: H3mPosition
  LoseConditionDays: number
  TeamsCount: number
  Teams: Array<number>
  AvailableHeroes: Array<string>
  CustomHeroesCount: number
  CustomHeroes: Array<H3mCustomHeroes>
  Players: Array<H3mPlayer>
  Tiles: Array<H3mTile>
}

export interface HeroesServer {
  getMap(args: GetMapArgs, headers?: object): Promise<GetMapReturn>
  listMaps(headers?: object): Promise<ListMapsReturn>
}

export interface GetMapArgs {
  filename: string
}

export interface GetMapReturn {
  m: Map  
}
export interface ListMapsArgs {
}

export interface ListMapsReturn {
  maps: Array<string>  
}


  
//
// Client
//
export class HeroesServer implements HeroesServer {
  protected hostname: string
  protected fetch: Fetch
  protected path = '/rpc/HeroesServer/'

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname
    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)
  }

  private url(name: string): string {
    return this.hostname + this.path + name
  }
  
  getMap = (args: GetMapArgs, headers?: object): Promise<GetMapReturn> => {
    return this.fetch(
      this.url('GetMap'),
      createHTTPRequest(args, headers)).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          m: <Map>(_data.m)
        }
      })
    })
  }
  
  listMaps = (headers?: object): Promise<ListMapsReturn> => {
    return this.fetch(
      this.url('ListMaps'),
      createHTTPRequest({}, headers)
      ).then((res) => {
      return buildResponse(res).then(_data => {
        return {
          maps: <Array<string>>(_data.maps)
        }
      })
    })
  }
  
}

  
export interface WebRPCError extends Error {
  code: string
  msg: string
	status: number
}

const createHTTPRequest = (body: object = {}, headers: object = {}): object => {
  return {
    method: 'POST',
    headers: { ...headers, 'Content-Type': 'application/json' },
    body: JSON.stringify(body || {})
  }
}

const buildResponse = (res: Response): Promise<any> => {
  return res.text().then(text => {
    let data
    try {
      data = JSON.parse(text)
    } catch(err) {
      throw { code: 'unknown', msg: `expecting JSON, got: ${text}`, status: res.status } as WebRPCError
    }
    if (!res.ok) {
      throw data // webrpc error response
    }
    return data
  })
}

export type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>
